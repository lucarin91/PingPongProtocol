# Ping/Pong protocol simulation
The scope of this project is to simulate the PING/PONG protocol in a GNutella network. The software aim to simulate this kind of protocol, and all the test are done in with this purpuse, but actually the general contruction can bring this software to future extension for other p2p simulation.

![Simulator in action](/img/example-small.jpg)

The idea of the software is to create an infinite loop where each time the simulation engine call a peer to execute same of its tasks, that in this specific case are pop a message from the buffer and work with it. To better simulate the this specific protocol the Peer have also, as in the real situation, the possibility to wait same amount of time, and then do something.

# Feature
- Random peer topology generation, given the number of nodes, the probability of connection and a random seed.
- Prob and log a set of specific peers, either in the standard output or in a file.
- Simple json like configuration file.
- Two different mode: simulation with the log of the behaver of the peer and  simple message analyses.
- Three type of implementation of the PING/PONG protocol, on demand, with persistent cache and dynamic cache.
- Simple Peer interface easily extendibles with the onEvent methods.

# Keey point of the PING/PONG implementation
In this section we will see all the key idea behind the implementation of the three version of the Ping/Pong protocal. In general this simulation want to test only how the message are excenged by this kind of protocal, and how is the improvement of the

## On demand ping
This is the base structure of the ping/pong protocol, the peer when externally triggered, broadcasts a ping to all its neighbor, this is done by using the method `putMessage(Message)` which push a new message on the neighbor's queue. Then all the peer that receive a ping respond with a pong and forwarr the ping to the other peer.

An important aspect is how routing the pong toward the original sender of the ping. To achieve this is use an hashMap where store the original sender of every received message. the structure have as key the iid of the message and as value the UID of the neighbor that send that message (in general it ccan be different from the original sender). In this way ecploting this information the peers can hoop by hoop back routing the pong to the original sender. More in detail this is the used std structure:
```
std::unordered_map<int, int> pingTable;
```
It's important to consider that the access of this structure is in constant time, so this create the minimal overhead every time the peer receive one pong. The same structure is also used to recognize the ping sent by the peer itself and the pong that are answer of its ping, in fact each time a peer send a new ping (originally generated by it) it insert in the pingTable the id of the message and a constant -1.
In this way is possible to do same other check during the ping forwarding, to improve the effective of the broadcast and reduce the content replication:
- not forwarded the ping already forwarded, is possible that there is a cycle in the peer graph.
- recognize and don't forward its ping.
- recognize and don't forward its pong.

## Simple Pong Cache
This version of the peer have all the structure explained before for the on demand ping, but it also have:
- the ping are sent after a variable number of second (random between 5 and 30 seconds)
- the peer exploit a cache of pong, that avoid to forward every time all the ping to the neighbor.

The implmentation of the pongCache is driven by the idea to have a fasten data structure with constant time for insetion and retrival, because it have to be access every tiime a peer receive a new ping from the network.

Practically the structure is a hashmap of hashmap, to exploit the constant access to retrive the cache entry for one of the neighbor, and to avoid replication of the Pong of the same original sender.
```
std::unordered_map<int, // neighbor id
                   std::unordered_map<int, // original sender
                                      unique_ptr<Message>>> pongCache;
```
Indeed logically the structure it can be consider a set of different cache, one for every neighbor, in which isnside there are a key value pair, with the original sender of the message and the message it self.

To clarify this type of structure we can analyse the beieviior of the cache when it will be filled by new pong and when this pong are retrived and send back to the requestor.
First of all every time a new Pong arrive from one of the incoming link this new message is saved in the cache of that neighbor, a nd using the UID of the original sender as second index of the structure. In this way erery time a new Pong  from the same original sender arrive it override he old one and not create any duplication in the cache.

In the other case study when a new ping arrive from one of the neighbor ping, it starts a loop on all the cache of the nighbord and if at least one message is present on the cache, it will be send to the requester and the ping is not forwarding on that link.

# Dynamic Pong Cache
This version of the peer have all the cache facility of the previous version, but improve the system with a dynamic cache where every entry are deleted after a number of second (by default 60). To create this new feature it is not modify at all the previous cache structure but instead is added a Linked List where store all the time information needed by filtering process.

More in detail every time the peer receive a Pong it is stored in the pongCache ad in the previous example, but ins also addend a new entry in the timeList at the end of the list,. with the the timestap generated by adding the actual time to the default experience value of 60 seconds. In this way the list is every time ordered by the time stamp of the cache entry.

Than every 30 second by default the filtering process of the cache start, and the list is scanned to find element with a time stamp less of the actual time. When a entry with this characteristic is found the system use the information stored inside the linked list node to remove the cache entry in the pongCache. It can be easilly see that the process filtering process can be stop before that alla the list is scanned, because when a list node with a greater time stamp of the actual time is found, by the insertion at the back, no other node with less time stamp can be found.

# Implementation Detail
In this section we will see more in detail the structure of the classes with a description of the more relevant constructor and method for each of them.
The main class in the project are the `TopologyGen`, to manage and generate the peer structure, `Peer` rappresent a peer entity with or the logic to implement the protocol, and `Message` that simulate the structure of the ping ping message with the needed information. Than we also have to utility class one the `ArgsParser` to read the argument pass by the programm, and the `Logger` class use to probe and log the activity of the peers.

The to implement the three different type of the protocol the class Peer is extended and create the other two class `Peer_p` and `Peer_pp`, witch implements respectively the * simple pong cache* and the *dynamic pong cache*.

## TopologyGen
This class enerate and manage a peer topology, it can random create a peer connection or mannualy give a already define vector of peers. Here are the main contructor:
- `TopologyGen(vector<shared_ptr<Peer>> peers_list)` create a topologyGen object given an already define vector of Peers.

- `TopologyGen(Config& configuration_file)`  create a topologyGen object given a configuration file, it use the parameters in the configuration file to create a random topology.

- `TopologyGen(int n_of_node, double connection, long r_seed)`  create a topologyGen object manually given the number of nodes, the probability of connection and a random seed.


After the creation of the object is possible to interact with the peer by the following method:

- `void simulate(function<void(Peer&)> call_back)` this is the main interface with the peers, The function execute one cycle of simulation among the peers, and after execute the callback function. There are other version of this function in witch is possible to specified, how much work each peer have to compute, and the sleep time among different peer iteration.

- `void startPing(int p)` manually trigger the send of the ping message of one specific peer, it is usesful in the first version of the simutation, when the peer *on demand* send the pings.

- `void print()` this function just print the topology structure of the peers.

## Peer
It is the class specifying all the characteristic of a peer in the network, it have a list of connected peers, and a message queue where the other peers can put messages.
A. It can be created by the following constructor:
- `Peer()` create a new Peer with a unique id.
- `Peer(int uid, shared_ptr<Logger> l)` create a new instance with a specific id and a Logger object
- `Peer(shared_ptr<Logger> l)` create a new instance with a Logger.

- `void work(int time_quanto)` this method run th enumber of time rappresentat of the parameter time_quanto same work of the peers, this rappresent the real execution of the peer work. When invoked basically the peer first check if same timer are elapsed, and then pop a number of message equal to the parameter `time_quanto` from the queue, and then work on it.  

- `void putMessage(unique_ptr<Message> msg)` put a new message in the queue of the peer.

- `void sendPing()` trigger the peer to broadcast a new ping message to all their neighbor.

- `bool addNeighbor(shared_ptr<Peer> p)` add a new neighbor to the peer, this method simulate a bidirectional connection to a new peer. In this way after the executing of the method the two peers will have in their neighbor list the new connection.


In the Peer class there is also other event based method used to implement the actual behavior when a PING or PONG message arrive. This method are actually the method extended by the `Peer_p` ans `Peer_pp` class. More in detail we can see:
- `virtual void onValidPing(unique_ptr<Message> msg , int sender_neighbor)` and `virtual void onValidPong(unique_ptr<Message> msg, int sender_neighbor)` called when the peer receives a valid ping or pong (the TTL is not 0) with the received message and the neighbor that send it.

- `virtual void onErrorMsg(unique_ptr<Message> msg, ErrorType error, int neighbor)` called when a not valid message is sent to the peer, it contains a `ErrorType` that rapprendet the specific error of the message. It can be one of the following:
- `ALREADY_FORWARDED_PING` received a ping that is already forwarded and already is in my ping table.
- `UNOKNOW_PONG` received a pong for witch there isn't information in the ping table, so the routing back information is missing.
- `EXPIRED_MSG` the message received have a expired TTL.
- `MY_PING` receive my ping
- `MY_PONG` receive my pong, so actually it is good, it is here only to have a more general structure of the system.

## Message
This class represent the actual message exchanged between the peers. It don't have the exact structure of the PING/PONG message, but keep all the information needed to simulate the same behavior. The actual field are:
- `int id` the unique id of the message.
- `MsgType type` the type of the message: `PING` or `PONG`
- `int TTL` the time to live of the message by default it is set to 4
- `int HOPS` the hops that the message did, how many peer it traverse
- `int originalSender` it represent the id of the peer that generate the message the first time.
- `int lastSender` it represent the previous hop sender, in other wars the neighbor that send the message to the peer. In a real protocol implementation this information can be taken by the socket connection information, but in this here in the simulation each entry in the queue are identically so it is important to distinguish witch neighbor put the message


## Peer_p
This class extended `Peer` and add the a pong cache with the possibility to exploit the already saved pong instead of broadcast every time the ping and wait for all the pong. This is implemented by the following method:

- `virtual bool addPongCache(int neighbor, unique_ptr<Message> msg)` this method neighbor as key to archive the pong message in the cache; this is useful to retrieve the message in constant time.

- `virtual void sendChachedPong(int to,unique_ptr<Message> msg)` if at least one message is in the pong cache, send this pong without broadcast the ping. If no message are found in the cache the ping is regularly broadcast to the neighbor.

## Peer_pp
This class extended the `Peer_p` and add a linked list in witch store the time stamp of every cache entry. The node store inside the list have the following field:
```
struct ListNode {
  time_t tstamp;         //time stamp of the entry
  int    original_sender;
  int    neighbor_id;
  int    msg_id;
};
```
Extending the on `addPongCache` method of the `Peer_p` class each time a new pong is added to the cache is also add at the end of the list a new entry of the ListNode struct. The list in this way is organize with ordered time stamp.
Then to add the capability to send the pong store in the cache only if therei number is more tha K elment,. it is also extended the method `sendChachedPong` of the `Peer_p`.

This class add also another timeout that by default every 60 second by default check and clear the cache entry, as it is describe in the previous section.

# Statistics


# How run it
